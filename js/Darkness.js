// Generated by CoffeeScript 1.11.1
var AnimatedValue, ReactType, TapResponder, View, isType, steal, type;

AnimatedValue = require("Animated").AnimatedValue;

TapResponder = require("TapResponder");

ReactType = require("modx/lib/Type");

isType = require("isType");

steal = require("steal");

View = require("modx/lib/View");

type = ReactType("Darkness");

type.defineOptions({
  color: String.withDefault("#000"),
  value: Number,
  minValue: Number.withDefault(0),
  maxValue: Number.withDefault(1),
  ignoreTouches: Boolean.withDefault(false),
  isNative: Boolean.withDefault(false),
  tap: TapResponder
});

type.defineValues(function(options) {
  return {
    _tap: options.tap
  };
});

type.defineFrozenValues(function(options) {
  return {
    color: options.color,
    minValue: options.minValue,
    maxValue: options.maxValue
  };
});

type.defineReactiveValues(function(options) {
  return {
    ignoreTouches: options.ignoreTouches
  };
});

type.defineAnimatedValues(function(options) {
  var ref;
  return {
    opacity: AnimatedValue((ref = options.value) != null ? ref : options.minValue, {
      isNative: options.isNative
    })
  };
});

type.defineReactions({
  _containerEvents: function() {
    if (this.ignoreTouches) {
      return "none";
    }
    if (this.opacity.get() === 0) {
      return "none";
    }
    return "auto";
  }
});

type.defineListeners(function() {
  var fn, tap;
  if (fn = this.props.onTap) {
    tap = this._tap != null ? this._tap : this._tap = TapResponder();
    return tap.didTap(fn);
  }
});

type.definePrototype({
  value: {
    get: function() {
      return this.opacity.get();
    },
    set: function(value) {
      return this.opacity.set(value);
    }
  },
  progress: {
    get: function() {
      return (this.opacity.get() - this.minValue) / (this.maxValue - this.minValue);
    },
    set: function(progress) {
      return this.opacity.set(this.minValue + progress * (this.maxValue - this.minValue));
    }
  }
});

type.defineGetters({
  animation: function() {
    return this.opacity.animation;
  },
  didResponderGrant: function() {
    return this._tap.didGrant.listenable;
  },
  didResponderEnd: function() {
    return this._tap.didEnd.listenable;
  }
});

type.defineMethods({
  animate: function(config) {
    var progress;
    progress = steal(config, "progress");
    if (isType(progress, Number)) {
      config.toValue = this.minValue + progress * (this.maxValue - this.minValue);
    }
    return this.opacity.animate(config);
  },
  stopAnimation: function() {
    return this.opacity.stopAnimation();
  }
});

type.defineProps({
  onTap: Function
});

type.render(function() {
  var ref;
  return View({
    style: this.styles.container(),
    pointerEvents: this._containerEvents,
    mixins: [(ref = this._tap) != null ? ref.touchHandlers : void 0]
  });
});

type.defineStyles({
  container: {
    cover: true,
    backgroundColor: function() {
      return this.color;
    },
    opacity: function() {
      return this.opacity;
    }
  }
});

module.exports = type.build();
